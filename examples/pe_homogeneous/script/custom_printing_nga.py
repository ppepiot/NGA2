""" Module containing all print routines needed to generate fortran
chemical kinetics source terms

"""

# Import statements
from ARCANE import tools as tools
from ARCANE import display as display

import numpy as np

import datetime
import os

logger = display.Logger()
logger.set_log('logCompute')


def print_header(print_variables, use):
    """Prints the header for the fortran file

    Parameters
    ----------
    print_variables :
        dictionary containing the f90 file to write in and code specific infos
    use :
        code for which fortran file is written

    """

    f = print_variables['f']
    f90_filename = print_variables['f90_filename']
    routine_name = print_variables['routine_name']
    rrate = print_variables['rrate']
    expo = print_variables['exponential']
    supplementary_info = print_variables['supp_info']

    # Initialising non existant entries
    if not supplementary_info:
        supplementary_info = {}

    for key in ['details', 'authors', 'since', 'note']:
        if key not in supplementary_info:
            supplementary_info[key] = ''

    # Formatting for better looking header
    supplementary_info['details'] = supplementary_info['details'].replace('\n', '\n!!             ')
    supplementary_info['note'] = supplementary_info['note'].replace('\n', '\n!!             ')

    # Date in YYYY/MM/DD format
    date = datetime.datetime.now().strftime("%Y/%m/%d")

    # date of last modification
    last_modified = '2019/01/24'

    # If existing environment variable, retrieves the author
    if 'ARCANE_AUTHOR' in os.environ and not supplementary_info['authors']:
        supplementary_info['authors'] = os.environ.get('ARCANE_AUTHOR')

    if use in ['Cantera', 'AVBP', 'YALES2', 'NTMIX', 'NGA2']:

        if not supplementary_info['since']:
            version_getter = 'ARCANE_' + use + '_version'
            if version_getter in os.environ:
                supplementary_info['since'] = os.environ.get(version_getter)

        # Author specific blocks
        supplementary_authors = ''
        if rrate and use == 'AVBP':
            supplementary_authors += ', J. Wirtz'
            last_modified = '2019/01/24'
        if expo:
            supplementary_authors += ', S. Blanchard, T. Ogier'
            last_modified = '2020/07/17'
        if use == 'NTMIX':
            supplementary_authors += ', A. Pestre'
            last_modified = '2020/05/22'

        f.write("""\
!--------------------------------------------------------------------------------------------------
!     Copyright (c) CERFACS (all rights reserved)
!--------------------------------------------------------------------------------------------------
!     FILE {0}
!>    @file {0}
!!    Module for calculating the analytical source terms in {1}
!!    @details {2}
!!    @authors {3}
!!    @date    {4}
!!    @since   {5}
!!    @note    {6}
!--------------------------------------------------------------------------------------------------

!--------------------------------------------------------------------------------------------------
!     MODULE mod_{7}
!>    @details Generated by ARCANE custom kinetics routine to compute the chemical source terms.
!!    @authors Q. CazÃ¨res, P. Pepiot{8}
!!    @date    {9}
!--------------------------------------------------------------------------------------------------
""".format(f90_filename, use,
           supplementary_info['details'],
           supplementary_info['authors'],
           date,
           supplementary_info['since'],
           supplementary_info['note'],
           routine_name, supplementary_authors, last_modified))

    else:

        logger.warning("Need to code proper header for fortran file for target", use)


def print_declarations(print_variables, constants, mech_variables, qss_variables, reactions_variables, use,
                       semi_implicit_bool):
    """Prints the constants declaration in the f90 file

    Parameters
    ----------
    print_variables :
        dictionary containing the f90 file to write in and code specific infos
    constants :
        dictionary of constants needed for computation
    mech_variables :
        dictionary of mechanism related parameters needed for computation
    qss_variables :
        dictionary of qss related parameters needed for computation
    reactions_variables :
        dictionary of reactions related parameters needed for computation
    use :
        code for which fortran file is written
    semi_implicit_bool :
        if True, calls the semi-implicitation routine

    """

    f = print_variables['f']
    precision = print_variables['precision']
    routine_name = print_variables['routine_name']

    Rcst = constants['Rcst']
    ns = constants['ns']
    nr = constants['nr']
    nr_reverse = constants['nr_reverse']
    nFO = constants['nFO']
    nFO_reverse = constants['nFO_reverse']
    nTB = constants['nTB']
    nTB_reverse = constants['nTB_reverse']
    nPlog = constants['nPlog']
    nPlog_reverse = constants['nPlog_reverse']
    nqss = constants['nqss']
    ne = constants['ne']
    elements = mech_variables['elements']

    mech = mech_variables['mech']
    species = mech_variables['species']

    species_qss_names = qss_variables['species_qss_names']
    if species_qss_names:
        qss_index_global = qss_variables['qss_index_global']

    reac_label = reactions_variables['reac_label']
    reac_direction = reactions_variables['reac_direction']
    ThreeBodiesindex = reactions_variables['ThreeBodiesindex']
    FallOffindex = reactions_variables['FallOffindex']
    Plogindex = reactions_variables['Plogindex']
    Plog_pressures = reactions_variables['Plog_pressures']

    # Declaration of all variables of modules
    text = 'module mod_' + routine_name + '\n'

    if use == 'AVBP':
        text += '  use mod_param_defs\n'
    if use == 'NGA2':
        text += '  use precision,         only:{0}\n'

    text += '  implicit none\n\n'

    if use in ['Cantera', 'YALES2', 'NTMIX']:
        text += '  integer, parameter :: {0} = selected_real_kind(15,307)\n\n'


    text += '  ! Ideal gas constant\n'
    # Potential problem with units
    text += '  real({0}), parameter :: Rcst = ' + str(Rcst) + '_' + precision + '\n'
    text += '  \n'
    text += '  ! Use semi-implicit formulation for select species' + '\n'
    text += '  logical, parameter :: semiImplicit = .' + str(semi_implicit_bool) + '.' + '\n'
    text += '  \n'
    text += '  ! Number of elements in the chemical system \n'
    text += '  integer, parameter :: ne = ' + str(ne) + '\n'
    text += '  \n'
    text += '  ! Number of non-qss and qss species and reactions' + '\n'
    text += '  integer, parameter :: nspec = ' + str(ns - nqss) + '\n'
    text += '  integer, parameter :: nqss = ' + str(nqss) + '\n'
    text += '  integer, parameter :: nreac = ' + str(nr) + '\n'
    text += '  integer, parameter :: nreac_reverse = ' + str(nr_reverse) + '\n'
    text += '  \n'
    text += '  ! Actual expression of each reaction\n'
    text += '  character(len=330), dimension(nreac + nreac_reverse) :: reacexp\n'
    text += '  \n'
    text += '  ! Number of thirdbodies' + '\n'
    text += '  integer, parameter :: nTB = ' + str(nTB) + '\n'
    text += '  integer, parameter :: nFO = ' + str(nFO) + '\n'
    text += '  integer, parameter :: nTB_reverse = ' + str(nTB_reverse) + '\n'
    text += '  integer, parameter :: nFO_reverse = ' + str(nFO_reverse) + '\n'
    if Plogindex:
        text += '  ! Number of pressure dependent arrhenius sets' + '\n'
        text += '  integer, parameter :: nPlog = ' + str(nPlog) + '\n'
        text += '  integer, parameter :: nPlog_reverse = ' + str(nPlog_reverse) + '\n'
    text += '  \n'

    text = text.format(precision)

    # Elements
    text += '  ! Index of elements' + '\n'
    e = 1
    for i, mys in enumerate(elements):
        text += '  integer, parameter :: e' + mys + ' = ' + str(e) + '\n'
        e += 1
    text += '\n'

    text += '  ! Index of species' + '\n'
    # Species
    k = 1
    for i, mys in enumerate(species):
        if mys not in species_qss_names:
            text += '  integer, parameter :: s' + mys + ' = ' + str(k) + '\n'
            k += 1
    text += '\n'

    # Species QSS
    if nqss > 0:
        for i, mys in enumerate(species_qss_names):
            text += '  integer, parameter :: sqss' + mys + ' = ' + str(i + 1) + '\n'
        text += '\n'

    text += '  ! Index of reactions' + '\n'
    # Reactions
    for i in range(nr + nr_reverse):
        text += '  integer, parameter :: r' + str(reac_label[i]) + reac_direction[i] + ' = ' + str(i + 1) + '\n'
    text += '  \n'

    if nTB + nFO > 0:
        text += '  ! Index of third body species' + '\n'
        # Three Bodies species
        i = 1
        if nTB > 0:
            for myr in ThreeBodiesindex:
                if myr < nr:
                    text += '  integer, parameter :: mM' + str(reac_label[myr]) + ' = ' + str(i) + '\n'
                    i += 1
            text += '  \n'

        # FallOff species
        if nFO > 0:
            for myr in FallOffindex:
                if myr < nr:
                    text += '  integer, parameter :: mM' + str(reac_label[myr]) + ' = ' + str(i) + '\n'
                    i += 1
            text += '  \n'

    # Three Bodies reactions
    if nTB > 0:
        text += '  ! Index of third body reactions\n'
        for i in range(nTB + nTB_reverse):
            text += '  integer, parameter :: TBr' + str(reac_label[ThreeBodiesindex[i]]) + reac_direction[
                ThreeBodiesindex[i]] + ' = ' + str(i + 1) + '\n'
        text += '  \n'

    # FallOff reactions
    if nFO > 0:
        text += '  ! Index of fall off reactions\n'
        for i in range(nFO + nFO_reverse):
            text += '  integer, parameter :: FOr' + str(reac_label[FallOffindex[i]]) + reac_direction[
                FallOffindex[i]] + ' = ' + str(i + 1) + '\n'
        text += '  \n'

    if nPlog > 0:
        text += '  ! Pressure dependent arrhenius reactions\n'
        k = 1
        for i in range(len(Plogindex)):
            for index in range(Plog_pressures[reac_label[i] - 1]):
                text += '  integer, parameter :: Plogr' + str(reac_label[Plogindex[i]]) + reac_direction[
                    Plogindex[i]] + str(index + 1) + ' = ' + str(k) + '\n'
                k += 1
        text += '  \n'

    # Molar mass
    text += '  ! Molar mass\n'
    text += '  real({0}), parameter, dimension(nspec) :: W_sp =(/ &'
    MW = mech.molecular_weights
    count = 0
    for i in range(ns):
        if species[i] not in species_qss_names:
            text += '\n' + '       ' + str(tools.format_to_significant(MW[i] / 1000.0, 15)) + '_' + precision
            if count < ns - nqss - 1:
                text += ','
            text += ' & ! ' + species[i]
            count += 1
    if species_qss_names:
        for i in range(nqss):
            text += '\n' + '      !' + str(tools.format_to_significant(MW[int(qss_index_global[i])] / 1000.0, 15)) \
                    + '_' + precision
            if i < nqss - 1:
                text += ','
            text += ' & ! ' + species_qss_names[i]
    text += '\n' + '       /)' + '\n'
    text += '  \n'

    text += 'contains\n\n'

    text = text.format(precision)

    f.write(text)


def print_reaction_expressions(print_variables, constants, reactions_variables):
    """Prints the explicit name of the reactions.

    Parameters
    ----------
    print_variables :
        dictionary containing the f90 file to write in and code specific infos
    constants :
        dictionary of constants needed for computation
    reactions_variables :
        dictionary of reactions related parameters needed for computation

    """
    f = print_variables['f']
    text = """\
  ! ----------------------------------------------- !
  !     Subroutine for explicit reaction names      !
  ! ----------------------------------------------- !
  subroutine reaction_expressions
    implicit none
    """
    text += '\n'

    nr = constants['nr']
    nr_reverse = constants['nr_reverse']
    reacname = reactions_variables['reac_names']
    for i in range(nr + nr_reverse):
        if i >= nr:
            text += '    reacexp(' + str(i + 1) + ') = ' + '\"reverse of ' + str(reacname[i]) + '\"\n'
        else:
            text += '    reacexp(' + str(i + 1) + ') = ' + '\"' + str(reacname[i]) + '\"\n'
    text += '\n'
    text += '  end subroutine reaction_expressions\n\n'

    f.write(text)

def print_species_names(print_variables,use, mech_variables):
    """Prints the explicit name of the species.

    Parameters
    ----------
    print_variables :
        dictionary containing the f90 file to write in and code specific infos
    mech_variables :
        dictionary of mechanism related parameters needed for computation

    """
    f = print_variables['f']
    species = mech_variables['species']
    if use == 'NGA2':
        charDecl = 'use string, only: str_medium'
        charlen = 'str_medium'
    else:
        charDecl = ''
        charlen = 20
    text = """\
  ! ----------------------------------------------- !
  !     Subroutine for explicit species names       !
  ! ----------------------------------------------- !
  subroutine get_species_names(names)
    {0}
    implicit none
    character(len={1}), dimension(nspec) :: names
    """.format(charDecl, charlen)
    text += '\n'

    for i, mys in enumerate(species):
        text += '    names(s' + mys + ')= "' + str(mys) + '"\n'
    text += '\n    return\n'
    text += '  end subroutine get_species_names\n\n'

    f.write(text)

def print_lindemann(print_variables):
    """Prints the pressure dependent coefficients handeling in the f90 file

    Parameters
    ----------
    print_variables :
        dictionary containing the f90 file to write in and code specific infos

    """
    f = print_variables['f']
    precision = print_variables['precision']

    text = """\
  ! ----------------------------------------------- !
  ! Subroutine for pressure dependent coefficients  !
  ! ----------------------------------------------- !
  real({0}) function getlindratecoeff(Tloc,k0,kinf,fc,concin,Ploc)
    implicit none

    real({0}) ::  Tloc,k0,kinf,fc,redP,Ploc
    real({0}) :: ntmp,ccoeff,dcoeff,lgknull
    real({0}) :: f
    real({0}) :: conc, concin

    if (concin.gt.0.0_{0}) then
       conc = concin
    else
       conc = Ploc / ( Rcst * Tloc )
    end if
    
    redP = abs(k0) * conc / max(abs(kinf), tiny(1.0_{0})) + tiny(1.0_{0})

    ntmp = 0.75_{0} - 1.27_{0} * log10( fc )
    ccoeff = - 0.4_{0} - 0.67_{0} * log10( fc )
    dcoeff = 0.14_{0}
    lgknull = log10(redP)
    f = (lgknull+ccoeff)/(ntmp-dcoeff*(lgknull+ccoeff))
    f = fc**(1.0_{0} / ( f * f + 1.0_{0} ))
    
    getlindratecoeff = kinf * f * redP / ( 1.0_{0} + redP )

  end function getlindratecoeff

"""
    text = text.format(precision)

    f.write(text)


def print_third_body(print_variables, constants, mech_variables, reactions_variables):
    """Prints the third body handling part in f90 file

    Parameters
    ----------
    print_variables :
        dictionary containing the f90 file to write in and code specific infos
    constants :
        dictionary of constants needed for computation
    mech_variables :
        dictionary of mechanism related parameters needed for computation
    reactions_variables :
        dictionary of reactions related parameters needed for computation

    """

    f = print_variables['f']
    precision = print_variables['precision']

    nr = constants['nr']

    mech = mech_variables['mech']

    ThreeBodiesindex = reactions_variables['ThreeBodiesindex']
    FallOffindex = reactions_variables['FallOffindex']

    text = """\
  ! ----------------------------------------------- !
  ! Evaluate thirdbodies                            !
  ! ----------------------------------------------- !
  subroutine get_thirdbodies(M,c)
    implicit none

    real({0}), dimension(nspec) :: c
    real({0}), dimension(nTB + nFO) :: M

"""
    for myr in ThreeBodiesindex + FallOffindex:
        if myr < nr:
            efficiencies = mech.reaction(myr).efficiencies
            efficiencies_keys = list(efficiencies.keys())
            efficiencies_values = list(efficiencies.values())
            if efficiencies:
                # Detecting explicit third body
                explicit = False
                for key in efficiencies_keys:
                    if f"(+{key})" in mech.reaction(myr).equation:
                        explicit = True

                if not explicit:
                    text += '    M(mM' + str(myr + 1) + ') = (' + str(tools.format_to_significant(
                            efficiencies_values[0] - 1.0, 15)) + '_' + precision + ')*c(s' + efficiencies_keys[
                                0] + ') &' + '\n'
                    for i in range(1, len(efficiencies_keys)):
                        text += '         + (' + str(tools.format_to_significant(efficiencies_values[i] - 1.0, 15)) \
                                + '_' + precision + ')*c(s' + \
                                efficiencies_keys[i] + ') &' + '\n'
                    text += '         + sum(c)' + '\n\n'
                else:
                    text += '    M(mM' + str(myr + 1) + ') = c(s' + efficiencies_keys[0] + ')' + '\n\n'
            else:
                text += '    M(mM' + str(myr + 1) + ') = sum(c)' + '\n\n'
    text += '  end subroutine get_thirdbodies' + '\n'
    text += '  \n'

    text = text.format(precision)

    f.write(text)


def print_pdep(print_variables, constants, arrhenius_constants, mech_variables, reactions_variables):
    """Prints the pressure dependent part in f90 file

    Parameters
    ----------
    print_variables :
        dictionary containing the f90 file to write in and code specific infos
    constants :
        dictionary of constants needed for computation
    arrhenius_constants :
        dictionary containing the Arrhenius coefficients for classic reactions and falloff ones
    mech_variables :
        dictionary of mechanism related parameters needed for computation
    reactions_variables :
        dictionary of reactions related parameters needed for computation

    """
    f = print_variables['f']
    precision = print_variables['precision']

    nr = constants['nr']
    nr_reverse = constants['nr_reverse']
    nPlog = constants['nPlog']
    nPlog_reverse = constants['nPlog_reverse']

    mech = mech_variables['mech']

    reac_label = reactions_variables['reac_label']
    reac_direction = reactions_variables['reac_direction']
    reac_type = reactions_variables['reac_type']
    Plogindex = reactions_variables['Plogindex']
    Plog_pressures = reactions_variables['Plog_pressures']

    forward_arrh_pdep = arrhenius_constants['forward_arrh_pdep']

    reverse_arrh_pdep = arrhenius_constants['reverse_arrh_pdep']

    text = """\
  ! ----------------------------------------------- !
  ! Subroutine for pressure dependent coefficients  !
  ! with logarithmic interpolation                  !
  ! ----------------------------------------------- !
  subroutine get_pdep_rate_coefficients(k, Tloc, Ploc)
    implicit none

    real({0}), dimension(nreac + nreac_reverse) :: k
    real({0}), dimension(nPlog + nPlog_reverse) :: log_k_pdep, P_pdep
    real({0}) :: Tloc, Ploc, R_T_inv, T_log, P_log, P_inf, P_sup, a, b, log_P_sup, log_P_inf

    integer :: index_inf, index_sup, i

    ! Shorthands
    R_T_inv = 1.0_{0}/(Rcst*Tloc)
    T_log = log(Tloc)
    P_log = log(Ploc)


"""

    for index_loc, index_glob in enumerate(Plogindex):
        for index in range(len(forward_arrh_pdep[reac_label[index_glob] - 1])):
            P = tools.format_to_significant(forward_arrh_pdep[reac_label[index_glob] - 1][index][3], 15)
            text += '    P_pdep(Plogr' + str(reac_label[index_glob]) + reac_direction[index_glob] + str(index + 1) + \
                    ') = ' + str(P) + '_' + precision + '\n'

        text += '\n'

        for index in range(Plog_pressures[index_loc]):

            if index_glob < nr:
                log_A = tools.format_to_significant(np.log(forward_arrh_pdep[reac_label[index_glob] - 1][index][0]), 15)
                beta = tools.format_to_significant(forward_arrh_pdep[reac_label[index_glob] - 1][index][1], 15)
                Ea = tools.format_to_significant(-forward_arrh_pdep[reac_label[index_glob] - 1][index][2], 15)
            else:
                log_A = tools.format_to_significant(np.log(reverse_arrh_pdep[reac_label[index_glob] - 1][index][0]), 15)
                beta = tools.format_to_significant(reverse_arrh_pdep[reac_label[index_glob] - 1][index][1], 15)
                Ea = tools.format_to_significant(-reverse_arrh_pdep[reac_label[index_glob] - 1][index][2], 15)

            text += '    log_k_pdep(Plogr' + str(reac_label[index_glob]) + reac_direction[index_glob] + str(index + 1) + \
                    ') = ' + str(log_A) + '_' + precision
            if Ea != 0:
                text += ' + (' + str(Ea) + '_' + precision + ')*R_T_inv'
                if beta != 0:
                    text += ' + T_log *(' + str(beta) + '_' + precision + ')'
                text += '\n'
            else:
                if beta != 0:
                    text += '+ T_log *(' + str(beta) + '_' + precision + ')\n'
                else:
                    text += '\n'

        text += '\n'
        text += '    P_inf = 0.0_' + precision + '\n'
        text += '    P_sup = 1.0e+10_' + precision + '\n'
        text += '    ! Limit pressures \n'
        text += '    do i = Plogr' + str(reac_label[index_glob]) + reac_direction[index_glob] + str(1) + ', ' + \
                'Plogr' + str(reac_label[index_glob]) + reac_direction[index_glob] + str(
                Plog_pressures[index_loc]) + '\n'

        text += """\
      if (Ploc > P_pdep(i)) then
         if (P_pdep(i) > P_inf) then
           P_inf = P_pdep(i)
           index_inf = i
         end if
      end if
       if (Ploc < P_pdep(i)) then
         if (P_pdep(i) < P_sup) then
           P_sup = P_pdep(i)
           index_sup = i
         end if
       end if
    end do

    ! Linear interpolation on logarithms
    log_P_sup = log(P_pdep(index_sup))
    log_P_inf = log(P_pdep(index_inf))

    a = (log_k_pdep(index_sup) - log_k_pdep(index_inf)) / (log_P_sup - log_P_inf)
    b = log_k_pdep(index_inf) - a * log_P_inf
"""
        text += '    k(r' + str(reac_label[index_glob]) + reac_direction[index_glob] + ') = exp(a * P_log + b) \n'
        text += '\n'

    text += """\

    end subroutine get_pdep_rate_coefficients

"""
    text = text.format(precision)

    f.write(text)


def write_arrhenius(A, beta, Ea, alpha1=0, alpha2=0, alpha3=0, alpha4=0, precision='pr'):
    """From the Arrhenius coefficients, outputs the equation in formatted string

    Parameters
    ----------
    A :
        pre-exponential constant
    beta:
        temperature dependence
    Ea :
        activation energy 
    alpha1 :
         polynomial dependence in temperature, 1st order (Default value = 0)
    alpha2 :
         polynomial dependence in temperature, 2nd order (Default value = 0)
    alpha3 :
         polynomial dependence in temperature, 3rd order (Default value = 0)
    alpha4 :
         polynomial dependence in temperature, 4th order (Default value = 0)
    precision :
        precision of the float number for fortran(Default value = 'pr')

    Returns
    -------
    text : str
        equation in a formatted string

    """

    text = f"({A}_{precision})"

    # Token to flag if there is a preceding term
    token = False

    if any([float(Ea), float(beta), float(alpha1)]) != 0:
        text += "*exp("
        if float(Ea) != 0:
            text += f"({Ea}_{precision})*R_T_inv"
            token = True

        if float(beta) != 0:
            if token:
                text += " + "
                token = False

            text += f"({beta}_{precision})*T_log"
            token = True

        if float(alpha1) != 0:
            if token:
                text += " + "

            text += f"& \n            ({alpha1}_{precision})*Tloc"
            token = True

        if float(alpha2) != 0:
            if token:
                text += " + "
                token = False

            text += f"({alpha2}_{precision})*(Tloc**2)"
            token = True

        if float(alpha3) != 0:
            if token:
                text += " + "
                token = False

            text += f"& \n            ({alpha3}_{precision})*(Tloc**3)"
            token = True

        if float(alpha4) != 0:
            if token:
                text += " + "
                token = False

            text += f"({alpha4}_{precision})*(Tloc**4)"


        text += " )"

    text += "\n"

    return text


def print_rate_coeff(print_variables, constants, arrhenius_constants, mech_variables, reactions_variables):
    """Prints the rate coefficients expressions in the f90 file

    Parameters
    ----------
    print_variables :
        dictionary containing the f90 file to write in and code specific infos
    constants :
        dictionary of constants needed for computation
    arrhenius_constants :
        dictionary containing the Arrhenius coefficients for classic reactions and falloff ones
    mech_variables :
        dictionary of mechanism related parameters needed for computation
    reactions_variables :
        dictionary of reactions related parameters needed for computation

    """
    f = print_variables['f']
    precision = print_variables['precision']

    nr = constants['nr']
    nr_reverse = constants['nr_reverse']

    mech = mech_variables['mech']

    reac_label = reactions_variables['reac_label']
    reac_direction = reactions_variables['reac_direction']
    reac_type = reactions_variables['reac_type']
    FallOffindex = reactions_variables['FallOffindex']

    forward_arrh = arrhenius_constants['forward_arrh']
    forward_arrh_0 = arrhenius_constants['forward_arrh_0']
    forward_arrh_inf = arrhenius_constants['forward_arrh_inf']

    reverse_arrh = arrhenius_constants['reverse_arrh']
    reverse_arrh_0 = arrhenius_constants['reverse_arrh_0']
    reverse_arrh_inf = arrhenius_constants['reverse_arrh_inf']

    text = """\
  ! ----------------------------------------------- !
  ! Evaluate rate coefficients                      !
  ! ----------------------------------------------- !
  subroutine get_rate_coefficients(k,M,Tloc,Ploc)
    implicit none

    real({0}), dimension(nreac + nreac_reverse) :: k
    real({0}), dimension(nFO + nFO_reverse) :: k_0
    real({0}), dimension(nFO + nFO_reverse) :: k_inf
    real({0}), dimension(nFO + nFO_reverse) :: FC
    real({0}), dimension(nTB + nFO) :: M
    real({0}) :: Tloc,Ploc,R_T_inv,T_log,redP

    ! Rate coefficients
    R_T_inv = 1.0_{0}/(Rcst*Tloc)
    T_log = log(Tloc)

"""
    for i in range(nr + nr_reverse):
        if reac_type[i] == 5:
            text += f"    k(r{reac_label[i]}{reac_direction[i]}) = 0.0_{precision}\n"

        elif reac_type[i] != 4:
            if i < nr:
                rate_coefficients_array = forward_arrh
            else:
                rate_coefficients_array = reverse_arrh

            A = tools.format_to_significant(rate_coefficients_array[0, reac_label[i] - 1], 15)
            beta = tools.format_to_significant(rate_coefficients_array[1, reac_label[i] - 1], 15)
            Ea = tools.format_to_significant(-rate_coefficients_array[2, reac_label[i] - 1], 15)
            if i < nr:
                alpha1 = "0.0"
                alpha2 = "0.0"
                alpha3 = "0.0"
                alpha4 = "0.0"
            else:
                alpha1 = tools.format_to_significant(rate_coefficients_array[3, reac_label[i] - 1], 15)
                alpha2 = tools.format_to_significant(rate_coefficients_array[4, reac_label[i] - 1], 15)
                alpha3 = tools.format_to_significant(rate_coefficients_array[5, reac_label[i] - 1], 15)
                alpha4 = tools.format_to_significant(rate_coefficients_array[6, reac_label[i] - 1], 15)

            text += f"    k(r{reac_label[i]}{reac_direction[i]}) = "
            text += write_arrhenius(A, beta, Ea, alpha1=alpha1, alpha2=alpha2, alpha3=alpha3, alpha4=alpha4,
                                    precision=precision)

        else:
            local_index_reac = np.where(FallOffindex == reac_label[i] - 1)[0][0]

            if i < nr:
                rate_coefficients_array = forward_arrh_0
            else:
                rate_coefficients_array = reverse_arrh_0

            A = tools.format_to_significant(rate_coefficients_array[0, local_index_reac], 15)
            beta = tools.format_to_significant(rate_coefficients_array[1, local_index_reac], 15)
            Ea = tools.format_to_significant(-rate_coefficients_array[2, local_index_reac], 15)
            if i < nr:
                alpha1 = "0.0"
                alpha2= "0.0"
                alpha3 = "0.0"
                alpha4 = "0.0"
            else:
                alpha1 = tools.format_to_significant(rate_coefficients_array[3, local_index_reac], 15)
                alpha2 = tools.format_to_significant(rate_coefficients_array[4, local_index_reac], 15)
                alpha3 = tools.format_to_significant(rate_coefficients_array[5, local_index_reac], 15)
                alpha4 = tools.format_to_significant(rate_coefficients_array[6, local_index_reac], 15)

            text += f"    k_0(FOr{reac_label[i]}{reac_direction[i]}) ="
            text += write_arrhenius(A, beta, Ea, alpha1=alpha1, alpha2=alpha2, alpha3=alpha3, alpha4=alpha4,
                                    precision=precision)

            if i < nr:
                rate_coefficients_array = forward_arrh_inf
            else:
                rate_coefficients_array = reverse_arrh_inf

            A = tools.format_to_significant(rate_coefficients_array[0, local_index_reac], 15)
            beta = tools.format_to_significant(rate_coefficients_array[1, local_index_reac], 15)
            Ea = tools.format_to_significant(-rate_coefficients_array[2, local_index_reac], 15)
            if i < nr:
                alpha1 = "0.0"
                alpha2= "0.0"
                alpha3 = "0.0"
                alpha4 = "0.0"
            else:
                alpha1 = tools.format_to_significant(rate_coefficients_array[3, local_index_reac], 15)
                alpha2 = tools.format_to_significant(rate_coefficients_array[4, local_index_reac], 15)
                alpha3 = tools.format_to_significant(rate_coefficients_array[5, local_index_reac], 15)
                alpha4 = tools.format_to_significant(rate_coefficients_array[6, local_index_reac], 15)

            text += f"    k_inf(FOr{reac_label[i]}{reac_direction[i]}) ="
            text += write_arrhenius(A, beta, Ea, alpha1=alpha1, alpha2=alpha2, alpha3=alpha3, alpha4=alpha4,
                                    precision=precision)

            FallOffcoeff = mech.reaction(reac_label[i] - 1).falloff.parameters
            FallOffcoeff = [tools.format_to_significant(coeff, 15) for coeff in FallOffcoeff]

            if mech.reaction(reac_label[i] - 1).falloff.type == "Simple":
                text += f"    redP = abs(k_0(FOr{reac_label[i]}{reac_direction[i]})) * M(mM{reac_label[i]}) / max(abs(k_inf(FOr{reac_label[i]}{reac_direction[i]})), tiny(1.0_{precision})) + tiny(1.0_{precision})\n"
                text += f"    k(r{reac_label[i]}{reac_direction[i]}) = k_inf(FOr{reac_label[i]}{reac_direction[i]}) * redP / ( 1.0_{precision} + redP )\n"

            elif mech.reaction(reac_label[i] - 1).falloff.type == "Troe":
                text += f'    FC(FOr{reac_label[i]}{reac_direction[i]}) = ((1.0_{precision} - {FallOffcoeff[0]}_{precision})*exp(-Tloc/({FallOffcoeff[1]}_{precision})) ' \
                        f'+ ({FallOffcoeff[0]}_{precision})*exp(-Tloc/({FallOffcoeff[2]}_{precision})))'
                if float(FallOffcoeff[3]) != 0:
                    text += f'&\n              + exp(-({FallOffcoeff[3]}_{precision})/Tloc)\n'
                else:
                    text += '\n'

                text += f'    k(r{reac_label[i]}{reac_direction[i]}) = getlindratecoeff(Tloc, ' \
                        f'k_0(FOr{reac_label[i]}{reac_direction[i]}), ' \
                        f'k_inf(FOr{reac_label[i]}{reac_direction[i]}),' \
                        f'FC(FOr{reac_label[i]}{reac_direction[i]}), M(mM{reac_label[i]}),Ploc)\n'

            elif mech.reaction(reac_label[i] - 1).falloff.type == "SRI":

                text += f'    FC(FOr{reac_label[i]}{reac_direction[i]}) = {FallOffcoeff[3]}_{precision} * ({FallOffcoeff[0]}_{precision} * exp(-{FallOffcoeff[3]}_{precision}/Tloc) &\n              + exp(-Tloc/{FallOffcoeff[2]}_{precision}))**(1/(1+log10(redP)**2))'
                if float(FallOffcoeff[4]) != 0:
                    text += f'* Tloc**{FallOffcoeff[4]}_{precision}\n'
                else:
                    text += '\n'

                text += f"    redP = abs(k_0(FOr{reac_label[i]}{reac_direction[i]})) * M(mM{reac_label[i]}) / max(abs(k_inf(FOr{reac_label[i]}{reac_direction[i]})), tiny(1.0_{precision})) + tiny(1.0_{precision})\n"
                text += f"    k(r{reac_label[i]}{reac_direction[i]}) = k_inf(FOr{reac_label[i]}{reac_direction[i]}) * redP * FC(FOr{reac_label[i]}{reac_direction[i]}) / ( 1.0_{precision} + redP )\n"

            else:
                logger.warning(f"WARNING: The FallOff type {mech.reaction(reac_label[i] - 1).falloff.type} is not implemented yet, please contact a developer.")

    text += '  \n'
    text += '    return\n'
    text += '  end subroutine get_rate_coefficients\n\n'

    text = text.format(precision)

    f.write(text)

# NOTE: This function is modified to avoid usage of canterea
def print_reaction_rates(print_variables, constants, mech_variables, qss_variables, reactions_variables):
    """Prints the reaction rates expressions in the f90 file

    Parameters
    ----------
    print_variables :
        dictionary containing the f90 file to write in and code specific infos
    constants :
        dictionary of constants needed for computation
    mech_variables :
        dictionary of mechanism related parameters needed for computation
    qss_variables :
        dictionary of qss related parameters needed for computation
    reactions_variables :
        dictionary of reactions related parameters needed for computation

    """

    f = print_variables['f']
    precision = print_variables['precision']

    nr = constants['nr']
    nr_reverse = constants['nr_reverse']

    mech = mech_variables['mech']
    nur = mech_variables['nur']
    nup = mech_variables['nup']

    species_qss_names = qss_variables['species_qss_names']

    reac_label = reactions_variables['reac_label']
    reac_type = reactions_variables['reac_type']
    reac_direction = reactions_variables['reac_direction']

    text = """\
  ! ----------------------------------------------- !
  ! Evaluate reaction rates                         !
  ! ----------------------------------------------- !
  subroutine get_reaction_rates(w,k,m,c,cqss)
    implicit none

    real({0}), dimension(nspec) :: c
    real({0}), dimension(nqss) :: cqss
    real({0}), dimension(nreac + nreac_reverse) :: w,k
    real({0}), dimension(nTB + nFO) :: m

"""
    # Overcomming explicit third body expressions (2 A + B = A2 + B)
    nu_reac = nur - nup
    nu_reac[nu_reac >= 1] = 1
    nu_reac[nu_reac < 0] = 0

    nu_prod = nup - nur
    nu_prod[nu_prod >= 1] = 1
    nu_prod[nu_prod < 0] = 0

    for i in range(nr + nr_reverse):
        orders = mech.reaction[reac_label[i] - 1].orders
        if i < nr:
            reactants = mech.reaction[reac_label[i] - 1].reactants
            nu = nu_reac
        else:
            reactants = mech.reaction[reac_label[i] - 1].products
            nu = nu_prod

        reactants_keys = list(reactants.keys())
        reactants_keys = tools.convert_to_valid_fortran_var(reactants_keys)
        reactants_values = list(reactants.values())
        text += '    w(r' + str(reac_label[i]) + reac_direction[i] + ') = k(r' + str(reac_label[i]) + reac_direction[
            i] + ') '
        for j in range(len(reactants_keys)):
            c_name = 'c'
            s_name = 's'
            if reactants_keys[j] in species_qss_names:
                c_name = 'cqss'
                s_name = 'sqss'
            if reactants_keys[j] in list(orders.keys()):
                text += '* ' + c_name + '(' + s_name + reactants_keys[j] + ')**' + str(
                        orders[reactants_keys[j]]) + '_' + precision + ' '
            elif reactants_values[j] != 1:
                text += '* ' + c_name + '(' + s_name + reactants_keys[j] + ')**' + str(
                        reactants_values[j]) + '_' + precision + ' '

            # Default Cantera setting that can be wrong if not cautious
            # if reactants_values[j] > 1:
            #     text += '* ' + c_name + '(' + s_name + reactants_keys[j] + ')**' + str(
            #         reactants_values[j]) + '_' + precision + ' '
            else:
                text += '* ' + c_name + '(' + s_name + reactants_keys[j] + ') '
        if reac_type[i] == 2:
            text += '* m(mM' + str(reac_label[i]) + ')'
        text += '\n'
    text += '  \n'
    text += '    return\n'
    text += '  end subroutine get_reaction_rates\n'
    text += '  \n'

    text = text.format(precision)

    f.write(text)


def print_mass_to_concentration(print_variables,use):
    """Prints the expressions of the conversion between mass fractions and concentrations
    Concentrations are based on kmol, to be compatible with Cantera

    Parameters
    ----------
    print_variables :
        dictionary containing the f90 file to write in and code specific info
    use :
        'NTMIX' or else
        
    """

    f = print_variables['f']
    precision = print_variables['precision']
    routine_name = print_variables['routine_name']
    end_module_flag = print_variables['EM_flag']

    input_var = 'P, T'
    real_var = 'rho, P, T, inv_W_g'
    text_sup = """\

    ! Gas molecular weight inverse
    inv_W_g = 0.0_{0}
    do k =1, nspec
      inv_W_g = inv_W_g + y(k) / W_sp(k)
    end do

    ! Gas density
    rho = P / (Rcst * inv_W_g * T)
""".format(precision)

    if end_module_flag:
        end_module = 'end module mod_' + routine_name
    else:
        end_module = ''

    if use == 'NTMIX':
        comment = ''
    else :
        comment = '!'

    text = f"""\
  ! ----------------------------------------------- !
  ! Mass fractions to concentrations                !
  ! ----------------------------------------------- !
  subroutine y2c(y, W_sp, {input_var}, c)
    implicit none

    real({precision}),dimension(nspec) :: W_sp
    real({precision}),dimension(nspec) :: c, y
    real({precision}) :: {real_var}

    integer :: k
    {text_sup}
    ! Conversion
    c = y * rho / W_sp

    ! Concentrations clipping
    {comment}do  k = 1, nspec
    {comment}   if (c(k)<1.0e-20_{precision}) c(k) = 0.0_{precision}
    {comment}end do

        return
    end subroutine y2c

{end_module}
"""

    # text = text.format(precision, input_var, real_var, text_sup, end_module)

    f.write(text)


def print_production_rates(print_variables, constants, mech_variables, qss_variables, reactions_variables):
    """Prints the production rates expressions in the f90 file

    Parameters
    ----------
    print_variables :
        dictionary containing the f90 file to write in and code specific infos
    constants :
        dictionary of constants needed for computation
    mech_variables :
        dictionary of mechanism related parameters needed for computation
    qss_variables :
        dictionary of qss related parameters needed for computation
    reactions_variables :
        dictionary of reactions related parameters needed for computation

    """
    f = print_variables['f']
    precision = print_variables['precision']

    ns = constants['ns']
    nr = constants['nr']

    mech = mech_variables['mech']
    species = mech_variables['species']
    nur = mech_variables['nur']
    nup = mech_variables['nup']
    indr = mech_variables['indr']
    inds = mech_variables['inds']

    species_qss_names = qss_variables['species_qss_names']

    reac_label = reactions_variables['reac_label']
    reac_direction = reactions_variables['reac_direction']
    is_reversible = reactions_variables['is_reversible']

    text = """\
  ! ----------------------------------------------- !
  ! Evaluate production rates                       !
  ! ----------------------------------------------- !
  subroutine get_production_rates(cdot,w)
    implicit none

    real({0}), dimension(nspec) :: cdot
    real({0}), dimension(nreac + nreac_reverse) :: w

"""

    nu = nup - nur
    for i in range(ns):
        rindex = indr[inds == i]
        if species[i] not in species_qss_names:
            text += '    cdot(s' + species[i] + ') = 0.0_' + precision + ' '
            k = 0
            for myr in rindex:
                if nu[i, myr] != 0:
                    if nu[i, myr] == 1:
                        text += '&' + '\n' + '         +'
                    elif nu[i, myr] == -1:
                        text += '&' + '\n' + '         -'
                    elif nu[i, myr] > 0:
                        text += '&' + '\n' + '         + ' + str(nu[i, myr]) + '_' + precision + ' *'
                    elif nu[i, myr] < 0:
                        text += '&' + '\n' + '         ' + str(nu[i, myr]) + '_' + precision + ' *'
                    text += ' w(r' + str(reac_label[myr]) + reac_direction[myr] + ') '
                    if is_reversible[myr] == 1:
                        if nu[i, myr] != 0:
                            if nu[i, myr] == 1:
                                text += '&' + '\n' + '         -'
                            elif nu[i, myr] == -1:
                                text += '&' + '\n' + '         +'
                            elif nu[i, myr] > 1:
                                text += '&' + '\n' + '         - ' + str(nu[i, myr]) + '_' + precision + ' *'
                            elif nu[i, myr] < -1:
                                text += '&' + '\n' + '         + ' + str(-nu[i, myr]) + '_' + precision + ' *'
                            text += ' w(r' + str(reac_label[myr]) + reac_direction[k + nr] + ') '
                            k += 1
            text += '\n\n'
    text += '  \n'
    text += '    return\n'
    text += '  end subroutine get_production_rates\n\n\n'

    text = text.format(precision)

    f.write(text)


def print_production_rates_exp(print_variables, constants, mech_variables, qss_variables, reactions_variables, use):
    """Prints the production rates expressions in the f90 file, in their exponential form

    Parameters
    ----------
    print_variables :
        dictionary containing the f90 file to write in and code specific infos
    constants :
        dictionary of constants needed for computation
    mech_variables :
        dictionary of mechanism related parameters needed for computation
    qss_variables :
        dictionary of qss related parameters needed for computation
    reactions_variables :
        dictionary of reactions related parameters needed for computation
    use :
        'AVBP' or else
        
    """

### Note about exponential integration:
# a lot of investigation work was made about numerical stability of the method,
# mainly because of the fact the intrisincaly it may happen that we divide by very small numbers (ex: coef_A, concentration)
# if questions, ask blanchard@cerfacs.fr or pestre@cerfacs.fr

    f = print_variables['f']
    precision = print_variables['precision']
    implicit_exponential = print_variables['implicit_exponential']

    ne = constants['ne']
    ns = constants['ns']
    nr = constants['nr']
    nqss = constants['nqss']

    species = mech_variables['species']
    species_og = mech_variables['species_og']
    nur = mech_variables['nur']
    nup = mech_variables['nup']
    indr = mech_variables['indr']
    inds = mech_variables['inds']
    elements = mech_variables['elements']
    n_atoms_in_spec = mech_variables['n_atoms_in_spec']

    species_qss_names = qss_variables['species_qss_names']

    reac_label = reactions_variables['reac_label']
    reac_direction = reactions_variables['reac_direction']
    is_reversible = reactions_variables['is_reversible']

    if use == 'AVBP':
        text = """\

  ! ----------------------------------------------- !
  ! Evaluate production rates, exponential form     !
  ! ----------------------------------------------- !

  subroutine get_production_rates_exp(cdot,w,c,dtchem_sub,thickness)
    implicit none

    real({0}), dimension(nspec) :: cdot, c, coef_A, coef_B, c_next, c_corr
    real({0}), dimension(nreac + nreac_reverse) :: w
    real({0}) :: dtchem_sub
    real({0}) :: thickness
"""
    else:
        if not implicit_exponential:
            text = """\

  ! ----------------------------------------------- !
  ! Evaluate production rates, exponential form     !
  ! ----------------------------------------------- !

  subroutine get_production_rates_exp(cdot,w,c,dtchem_sub)
    implicit none

    real({0}), dimension(nspec) :: cdot, c, coef_A, coef_B, c_next, c_corr
    real({0}), dimension(nreac + nreac_reverse) :: w
    real({0}) :: dtchem_sub ! available from AVBP7.7
"""
        else: # Remove the correction variable c_corr
            text = """\

  ! ----------------------------------------------- !
  ! Evaluate production rates, exponential form     !
  ! ----------------------------------------------- !

  subroutine get_production_rates_exp(cdot,w,c,dtchem_sub)
    implicit none

    real({0}), dimension(nspec) :: cdot, c, coef_A, coef_B, c_next
    real({0}), dimension(nreac + nreac_reverse) :: w
    real({0}) :: dtchem_sub ! available from AVBP7.7
"""

    nu = nup - nur
    nu_check = abs(nu)

    if not implicit_exponential:
        for e in range(ne):
            text += '    real(' + precision + ') :: sum_' + elements[e] + '_atom, sum_' + elements[
                e] + '_atom_next, dAtom_' + elements[e] + '\n'
            text += '    real(' + precision + '), dimension(nspec) :: c_with_' + elements[e] + '\n'
        text += '    real(' + precision + '), dimension(ne) :: largest_c, vector_X_solution, vector_B_in, B_diag  \n'
        text += '    integer, dimension(ne, ne) :: matrix_A_in \n'
        text += '    real(' + precision + '), dimension(ne, ne) :: A_diag \n'
        text += '    real(' + precision + '), dimension(ne, ne+1) :: A_aug \n'
        text += '    integer, dimension(ne) :: ind_largest_c \n'
        text += '    integer :: det \n'
        text += '\n'

        text += '    ! Fill species composition\n'
        text += '    integer, dimension(ne,nspec) :: N_atoms_in_spec \n'
        for element_index in range(ne):
            for spec_index in range(ns - nqss):
                text += '      N_atoms_in_spec(e' + elements[element_index] + ',s' + species[spec_index] + ') = ' \
                        + str(int(n_atoms_in_spec(species_og[spec_index], elements[element_index]))) + '\n'

    text += '\n'

    text += '    ! Initializations \n'
    text += '    cdot(:) = 0.0_' + precision + '\n'
    text += '    coef_A(:) = 0.0_' + precision + '\n'
    text += '    coef_B(:) = 0.0_' + precision + '\n'
    text += '    c_next(:) = 0.0_' + precision + '\n'
    if not implicit_exponential:
        text += '    c_corr(:) = 0.0_' + precision + '\n'
        text += '    vector_X_solution(:) = 0.0_' + precision + '\n'
        text += '    vector_B_in(:) = 0.0_' + precision + ' \n'
        text += '    matrix_A_in(:,:) = 0 \n'
        text += '    vector_X_solution(:) = 0.0_' + precision + '\n'
        text += '    largest_c(:) = 0.0_' + precision + '\n'

        for e in range(ne):
            text += '    dAtom_' + elements[e] + ' = 0.0_' + precision + '\n'
            text += '    sum_' + elements[e] + '_atom = 0.0_' + precision + '\n'
            text += '    sum_' + elements[e] + '_atom_next = 0.0_' + precision + '\n'
            text += '    c_with_' + elements[e] + '(:) = 0.0_' + precision + '\n'
        text += '    ind_largest_c(:) = 0 \n'
        text += '    det = 0 \n'
        text += '    A_aug(:,:) = 0.0_' + precision + '\n'
        text += '    A_diag(:,:) = 0.0_' + precision + '\n'
        text += '    B_diag(:) = 0.0_' + precision + '\n'

    text += '\n'

    if not implicit_exponential:
        text += '    ! Compute total atoms number at current iteration \n'
        for e in range(ne):
            text += '    sum_' + elements[e] + '_atom = 0.0_' + precision + ' & \n'
            for s in range(ns - nqss):
                if (n_atoms_in_spec(species_og[s], elements[e])) > 0:
                    text += '         + c(s' + species[s] + ') * N_atoms_in_spec(e' + elements[e] + ',s' + species[
                        s] + ') & \n'
            text += '         + 0.0_' + precision + '\n'
            text += '\n'

    text += '    ! Compute concentrations at iteration n+1 following exponential method. tiny(1.0_' + precision  + ')' \
            + ' needed on A to avoid null denominator in concentrations calculation. \n'

    for i in range(ns):
        if species[i] not in species_qss_names:
            if sum(nu_check[i, :]) != 0:
                rindex = indr[inds == i]
                text += '    coef_A(s' + species[i] + ') = (0.0_' + precision + ' '
                k = 0
                for myr in rindex:  # forward
                    if nu[i, myr] != 0:
                        if nu[i, myr] == -1:
                            text += '&' + '\n' + '         -'
                            text += ' w(r' + str(reac_label[myr]) + reac_direction[myr] + ') '
                        elif nu[i, myr] < 0:
                            text += '&' + '\n' + '         ' + '- ' + str(abs(nu[i, myr])) + '_' + precision + ' *'
                            text += ' w(r' + str(reac_label[myr]) + reac_direction[myr] + ') '
                        elif is_reversible[myr] == 1:  # backward
                            if nu[i, myr] == 1:
                                text += '&' + '\n' + '         -'
                                text += ' w(r' + str(reac_label[myr]) + reac_direction[nr + k] + ') '
                            elif nu[i, myr] > 0:
                                text += '&' + '\n' + '         ' + '- ' + str(abs(nu[i, myr])) + '_' + precision + ' *'
                                text += ' w(r' + str(reac_label[myr]) + reac_direction[nr + k] + ') '
                            k += 1

                text += ')'
                text += ' / ( c(s' + str(species[i]) + ') + tiny(1.0_' + precision + '))'# - tiny(1.0_' + precision + ')' # -> if no clipping

                text += '\n\n'
                text += '    coef_B(s' + species[i] + ') = (0.0_' + precision + ' '
                k = 0
                for myr in rindex:  # forward
                    if nu[i, myr] != 0:
                        if nu[i, myr] == 1:
                            text += '&' + '\n' + '         +'
                            text += ' w(r' + str(reac_label[myr]) + reac_direction[myr] + ') '
                        elif nu[i, myr] > 0:
                            text += '&' + '\n' + '         ' + '+ ' + str(nu[i, myr]) + '_' + precision + ' *'
                            text += ' w(r' + str(reac_label[myr]) + reac_direction[myr] + ') '
                        elif is_reversible[myr] == 1:  # backward
                            if nu[i, myr] == -1:
                                text += '&' + '\n' + '         +'
                                text += ' w(r' + str(reac_label[myr]) + reac_direction[nr + k] + ') '
                            elif nu[i, myr] < 0:
                                text += '&' + '\n' + '         ' + '+ ' + str(abs(nu[i, myr])) + '_' + precision + ' *'
                                text += ' w(r' + str(reac_label[myr]) + reac_direction[nr + k] + ') '
                            k += 1

                text += ')'

                text += '\n\n'

############## Compute c_next: please keep comments for futher use or modifications

### Precision problems work (idea: use min/max if no clipping on reaction rates, but quite costly)
### Note: what if there is only creation? (B > 0 and A very small) -> use aymptotic expression?
#                text += '    IF ((coef_A(s' + str(species[i]) + ') > -1.0e-30_' + precision + ') .OR. (c(s' + str(species[i]) + ') < 1.0e-30_' + precision + '))  THEN \n'
#                text += '      c_next(s' + species[i] + ') = c(s' + str(species[i]) + ') + coef_B(s' + str(species[i]) + ') * dtchem_sub \n'
#                text += '    ELSE \n'
#                text += '      c_next(s' + species[i] + ') = max(coef_B(s' + str(species[i]) + ') / coef_A(s' + str(species[i]) + '), -1.0e+150_' + precision + ')'
#                text += ' * (exp(min(coef_A(s' + str(species[i]) + ') * dtchem_sub, -1.0e-150_' + precision + ')) - 1.0_pr) + c(s' + str(species[i]) + ') * exp(min(coef_A(s' + str(species[i]) + ') * dtchem_sub, -1.0e-150_' + precision + ')) \n'
#                text += '    END IF \n'

### VERSION OK avec clipping
#                text += '    c_next(s' + species[i] + ') = coef_B(s' + str(species[i]) + ') / coef_A(s' + str(species[i]) + ')'
#                text += ' * (exp(coef_A(s' + str(species[i]) + ') * dtchem_sub) - 1.0_pr) + c(s' + str(species[i]) + ') * exp(coef_A(s' + str(species[i]) + ') * dtchem_sub) \n'
#
#### Actually if A*dtchem_sub -> 0, c_next = c and creation of the species could be missed (asymptotic behaviour). Therefore:
#                text += '    IF (c_next(s' + species[i] + ') == c(s' + str(species[i]) + ')) THEN \n'
#                text += '      c_next(s' + species[i] + ') = c(s' + str(species[i]) + ') + coef_B(s' + str(species[i]) + ') * dtchem_sub \n'
#### We come back here the the "classic" expression, but normally here B shoud be very small so it will not be a problem
#                text += '    END IF \n'

### TEST idee Bene: developpement limite de exp pour eviter de diviser par A -> ne requiert pas de clipping, et donc n'est pas dependant de la machine
### Plus efficace en CPU -> on garde cette methode

                if use == 'AVBP':
                    text += '    IF ( exp(coef_A(s' + str(species[i]) + ') * dtchem_sub / thickness) == 1.0_pr ) THEN \n'
                    text += '      c_next(s' + species[i] + ') = coef_B(s' + str(species[i]) + ') * ( dtchem_sub / thickness + coef_A(s' + str(species[i]) + ')' \
                            ' *dtchem_sub*dtchem_sub/thickness/thickness/2 )  & \n' \
                            '      + c(s' + str(species[i]) + ') \n'
                    text += '    ELSE \n'
                    text += '      c_next(s' + species[i] + ') = coef_B(s' + str(species[i]) + ') / coef_A(s' + str(species[i]) + ')'
                    text += ' * (exp(coef_A(s' + str(species[i]) + ') * dtchem_sub / thickness) - 1.0_pr) & \n' \
                            '      + c(s' + str(species[i]) + ') * exp(coef_A(s' + str(species[i]) + ') * dtchem_sub / thickness) \n'
                    text += '    END IF \n '

                    text += '\n'

                else:
                    text += '    IF ( exp(coef_A(s' + str(species[i]) + ') * dtchem_sub) == 1.0_pr ) THEN \n'
                    text += '      c_next(s' + species[i] + ') = coef_B(s' + str(species[i]) + ') * ( dtchem_sub + coef_A(s' + str(species[i]) + ')  & \n' \
                            '       * dtchem_sub*dtchem_sub/2 ) + c(s' + str(species[i]) + ') \n'
                    text += '    ELSE \n'
                    text += '      c_next(s' + species[i] + ') = coef_B(s' + str(species[i]) + ') / coef_A(s' + str(species[i]) + ')'
                    text += ' * (exp(coef_A(s' + str(species[i]) + ') * dtchem_sub) - 1.0_pr)  & \n' \
                            '       + c(s' + str(species[i]) + ') * exp(coef_A(s' + str(species[i]) + ') * dtchem_sub) \n'
                    text += '    END IF \n '

                    text += '\n'

###############

    if not implicit_exponential:
        text += '    ! Compute total atoms number at iteration n+1 \n'
        for e in range(ne):
            text += '    sum_' + elements[e] + '_atom_next = 0.0_' + precision + ' & \n'
            for s in range(ns - nqss):
                if (n_atoms_in_spec(species_og[s], elements[e])) > 0:
                    text += '         + c_next(s' + species[s] + ') * N_atoms_in_spec(e' + elements[e] + ',s' + species[
                        s] + ') & \n'
            text += '         + 0.0_' + precision + '\n'
            text += '\n'

        text += '    ! Compute atoms number difference \n'
        for e in range(ne):
            text += '    dAtom_' + elements[e] + ' = sum_' + elements[e] + '_atom_next - sum_' + elements[e] + '_atom'
            text += '\n'
        text += '\n'

        text += '    ! A correction must be applied. ' \
                'The missing/excess atoms are splitted between ' + str(
            ne) + ' species \n'
        text += '    ! (as many as elements in the chemical system) with the largest local concentrations. ' \
                'The idea is to solve a linear system thanks to a Gaussian elimination AX = B \n\n'

        text += '    ! Determination of the largest species concentrations. \n'
        for e in range(ne):
            for s in range(ns - nqss):
                if (n_atoms_in_spec(species_og[s], elements[e])) > 0:
                    text += '    c_with_' + elements[e] + '(s' + species[s] + ') = c_next(s' + species[
                        s] + ') * N_atoms_in_spec(e' + elements[e] + ',s' + species[s] + ')\n'
            text += '\n'

        text += '    ! Each time a species is selected, ' \
                'its concentration for the next atom is set to 0 to not be selected twice \n'
        for e in range(ne):
            if e > 0:
                for e2 in range(e):  # as many species as elements
                    text += '    c_with_' + elements[e] + '(ind_largest_c(' + str(e2 + 1) + ')) = 0.0_' \
                            + precision + '\n'
            text += '    largest_c(' + str(e + 1) + ') = MAXVAL(c_with_' + elements[e] + '(:)) \n'
            text += '    ind_largest_c(' + str(e + 1) + ') = MAXLOC(c_with_' + elements[e] + '(:), DIM=1) \n\n'

        text += '    ! Fill the matrix A \n'
        for e in range(ne):
            for s in range(ne):
                text += '    matrix_A_in(' + str(e + 1) + ',' + str(s + 1) + ') = N_atoms_in_spec(e' + elements[
                    e] + ',ind_largest_c(' + str(s + 1) + ')) \n'
        text += '\n'

        text += '    ! Build B. Add minus sign on the dAtom because X will be directly the number of atoms ' \
                'to compensate the loss/excess of it \n'
        for e in range(ne):
            text += '    vector_B_in(' + str(e + 1) + ') = - dAtom_' + elements[e] + '\n'
        text += '   \n'

        text += '    ! Build the augmented matrix A_aug, on which the diagonalization process is performed \n'
        for e in range(ne):
            for e2 in range(ne+1):
                if ( e2 < (ne)):
                    text += '    A_aug(' + str(e+1) + ',' + str(e2+1) + ') = real(matrix_A_in(' + str(e + 1) + ',' + str(e2 + 1) + ')) \n'
                else:
                    text += '    A_aug(' + str(e+1) + ',' + str(e2+1) + ') = vector_B_in(' + str(e + 1) + ') \n'
        text += '   \n'

        text += '    ! Compute matrix A determinant: if det=0, the matrix is not inversible ' \
                'therefore the Gaussian elimination cannot work. In this case, none correction is applied \n'

        text += '    call diagonalize_matrix(A_aug, A_diag, B_diag, ne) \n'

        text += '    det ='
        for e in range(ne):
             if e < (ne-1):
                 text += ' A_diag(' + str(e+1) + ',' + str(e+1) + ') *'
             else:
                 text += ' A_diag(' + str(e+1) + ',' + str(e+1) + ') \n\n'

        text += '    IF (det /= 0) THEN \n\n'

        text += '      ! Now find the values of vector X \n'
        for i in range(ne):
            text += '      vector_X_solution(' + str(ne-i) + ') = 'f"B_diag({str(ne - i)}) \n"
            if i>0:
                for j in range(i):
                    text += '      vector_X_solution(' + str(ne-i) + ') = vector_X_solution(' + str(ne-i) + ') - 'f"A_diag({str(ne - i)},{str(ne - j)}) * vector_X_solution({str(ne - j)}) \n"
                text += '      vector_X_solution(' + str(ne-i) + ') = vector_X_solution(' + str(ne-i) + ') 'f"/ A_diag({str(ne - i)},{str(ne - j - 1)}) \n"
                text += '   \n'
            else:
                text += '      vector_X_solution(' + str(ne-i) + ') = vector_X_solution(' + str(ne-i) + ') 'f"/ A_diag({str(ne - i)},{str(ne)}) \n"
                text += '   \n'

        text += '      ! The solutions are known: the concentrations correction to be applied is computed for the ' + str(
            ne) + ' concerned species \n'
        for e in range(ne):
            text += f"      c_corr(ind_largest_c({str(e + 1)})) = vector_X_solution({str(e + 1)}) \n" \
    # security (modif Quentin)
    #                f"      !IF (c_corr(ind_largest_c({str(e + 1)})) /= c_corr(ind_largest_c({str(e + 1)}))) THEN\n" \
    #                f"      !  c_corr(ind_largest_c({str(e + 1)})) =  0.0_{precision}\n" \
    #                f"      !END IF\n\n"
        text += '    \n'
        text += '    END IF \n\n'

    text += '    ! Finally the source terms are computed with exponential method ' \
            'by taking into account the correction \n'
    for i in range(ns):
        if species[i] not in species_qss_names:
            if sum(nu_check[i, :]) != 0:
                if use == 'AVBP':
# security (modif Quentin)
#                    text += '    cdot(s' + str(species[i]) + ') = (max(c_next(s' + str(species[i]) + ') + c_corr(s' + str(
#                            species[i]) + '), tiny(1.0_' + precision + '))  - c(s' + str(
#                            species[i]) + ')) / dtchem_sub * thickness'
                    text += '    cdot(s' + str(species[i]) + ') = (c_next(s' + str(species[i]) + ') + c_corr(s' + str(
                            species[i]) + ') - c(s' + str(
                            species[i]) + ')) / dtchem_sub * thickness'

                    text += '\n'
                else:
                    if not implicit_exponential:
    # security (modif Quentin)
                        text += '    cdot(s' + str(species[i]) + ') = (max(c_next(s' + str(species[i]) + ') + c_corr(s' + str(
                               species[i]) + '), tiny(1.0_' + precision + ')) - c(s' + str(
                               species[i]) + ')) / dtchem_sub'
                        # text += '    cdot(s' + str(species[i]) + ') = (c_next(s' + str(species[i]) + ') + c_corr(s' + str(
                        #         species[i]) + ') - c(s' + str(
                        #         species[i]) + ')) / dtchem_sub'
                        text += '\n'
                    else:
                        text += '    cdot(s' + str(species[i]) + ') = (max(c_next(s' + str(species[i]) + '), tiny(1.0_' + precision + ')) - c(s' + str(
                               species[i]) + ')) / dtchem_sub'
                        text += '\n'
            else:
                text += '    cdot(s' + str(species[i]) + ') = tiny(1.0_' + precision + ')'
                text += '\n'

    text += '  \n'
    text += '    return\n'
    text += '  end subroutine get_production_rates_exp\n\n\n'

    text = text.format(precision)

    f.write(text)

def print_gauss_elimination_intern(print_variables):
    """Prints the Gauss elimination algorithm needed for mass conservation with exponential method
    
    Parameters
    ----------
    print_variables :
        dictionary containing the f90 file to write in and code specific infos
        
    """
    f = print_variables['f']
    precision = print_variables['precision']

    text = """\
  ! ----------------------------------------------------------------------------- !
  ! Diagonalize matrix (needed for exponential method)        		          !
  ! ----------------------------------------------------------------------------- !

  subroutine diagonalize_matrix(A_aug_in,A_diag_out,B_diag_out,n)
    !=========================================================================
    ! input ...
    ! A_aug_in(n,n+1)       - A augmented
    ! n                     - Number of equations (size of matrix A, not augemented)
    ! output ...
    ! A_diag_out            - Diagonalized A
    ! B_diag_out            - B after diagonalization
    ! internal ...
    ! A_aug_internal(n,n+1) - A augmented
    !=========================================================================

    implicit none
    integer, intent(in) :: n

    real(pr), dimension(n,n+1) :: A_aug_in, A_aug_internal
    real(pr), dimension(n) :: B_diag_out
    real(pr), dimension(n+1) :: t
    real(pr), dimension(n,n) :: A_diag_out
    integer i, j, k

    A_aug_internal = A_aug_in ! to not modify the input

    DO j=1,n

      ! pivot
      k = j
      DO i=j, n
        IF ( ABS(A_aug_internal(i,j)) > ABS(A_aug_internal(k,j)) ) k=i
      END DO

      t = A_aug_internal(j,:)
      A_aug_internal(j,:) = A_aug_internal(k,:)
      A_aug_internal(k,:) = t

      ! diagonalize
      DO i = (j+1), n
        A_aug_internal(i,:) = A_aug_internal(i,:) - A_aug_internal(j,:) * A_aug_internal(i,j) / A_aug_internal(j,j)
      END DO

    END DO


    ! resplit A and B for next step: solving X
    DO i=1, n
      DO j=1, (n+1)
        IF (j < (n+1) ) THEN
          A_diag_out(i,j) = A_aug_internal(i,j)
        ELSE
          B_diag_out(i) = A_aug_internal(i,j)
        END IF
      END DO
    END DO

  end subroutine diagonalize_matrix

  """

    text = text.format(precision)

    f.write(text)

def print_cantera_specific(print_variables, dt_exp_user):
    """Prints the Cantera specific calls in the f90 file

    Parameters
    ----------
    print_variables :
        dictionary containing the f90 file to write in and code specific infos
    dt_exp_user :
        user timestep with exponential integration
        
    """
    f = print_variables['f']
    precision = print_variables['precision']
    routine_name = print_variables['routine_name']
    Plog = print_variables['Plog']
    QSS = print_variables['QSS']
    TB = print_variables['TB']
    exponential = print_variables['exponential']

    text = """\
! ----------------------------------------------- !
! Cantera routine                                 !
! ----------------------------------------------- !
subroutine {1}(P, T, y, wdot)

  use mod_{1}
  implicit none

  real({0}), dimension(nspec) :: y, c, wdot, cdot
  real({0}), dimension(nqss) :: cqss
  real({0}), dimension(nreac + nreac_reverse) :: w,k
  real({0}), dimension(nTB + nFO) :: M
  real({0}) :: P, T, rho{6}

  ! Convert to concentrations
  call y2c(y, W_sp, P, T, c)

  ! Evaluate QSS concentrations and reaction rates{4}
  call get_rate_coefficients(k, M, T, P){2}{3}
  call get_reaction_rates(w, k, M, c, cqss)

  ! Evaluate production rates{5}

  return
end subroutine {1}

"""
    if Plog:
        PLog_text = '\n  call get_pdep_rate_coefficients(k,T,P)\n'
    else:
        PLog_text = ''

    if QSS:
        QSS_text = '\n  call get_qss(cqss, c, k, M)\n'
    else:
        QSS_text = ''

    if TB:
        TB_text = '\n  call get_thirdbodies(M,c)\n'
    else:
        TB_text = ''

    if exponential:
        dt_min_text = '\n  real(' + precision + ') :: dtchem_sub\n'
        production_text = '\n  dtchem_sub = ' + str(dt_exp_user) + '_' + precision + '\n'
        production_text += '  call get_production_rates_exp(wdot,w,c,dtchem_sub)\n'
    else:
        dt_min_text = ''
        production_text = '\n  call get_production_rates(wdot,w)\n'

    text = text.format(precision, routine_name, PLog_text, QSS_text, TB_text, production_text, dt_min_text)

    f.write(text)

def print_ntmix_specific(print_variables):
    """Prints the NTMIX specific calls in the F90 file

    Parameters
    ----------
    print_variables :
        dictionary containing the F90 file to write in and code specific infos

    """
    f = print_variables['f']
    precision = print_variables['precision']
    routine_name = print_variables['routine_name']
    Plog = print_variables['Plog']
    QSS = print_variables['QSS']
    TB = print_variables['TB']
    exponential = print_variables['exponential']
    classical = print_variables['classical']
    implicit_exponential = print_variables['implicit_exponential']

    text = """\
! ----------------------------------------------- !
! NTMIX routine                                 !
! ----------------------------------------------- !
subroutine {1}(P, T, y, wdot, dtchem_sub, classic_chem)

  use mod_{1}
  implicit none

  real({0}), dimension(nspec) :: y, c, wdot, cdot
  real({0}), dimension(nqss) :: cqss
  real({0}), dimension(nreac + nreac_reverse) :: w,k
  real({0}), dimension(nTB + nFO) :: M

  real({0}) :: P, T, rho, dtchem_sub

  logical :: classic_chem

  ! Convert to concentrations
  call y2c(y, W_sp, P, T, c)

  ! Evaluate QSS concentrations and reaction rates{4}
  call get_rate_coefficients(k, M, T, P){2}{3}
  call get_reaction_rates(w, k, M, c, cqss)

  ! Evaluate production rates{5}

  return
end subroutine {1}

"""
    if Plog:
        PLog_text = '\n  call get_pdep_rate_coefficients(k,T,P)\n'
    else:
        PLog_text = ''

    if QSS:
        QSS_text = '\n  call get_qss(cqss, c, k, M)\n'
    else:
        QSS_text = ''

    if TB:
        TB_text = '\n  call get_thirdbodies(M,c)\n'
    else:
        TB_text = ''

    production_text = ''
    if implicit_exponential:
        production_text += '\n  if (.not. classic_chem) then'
        production_text += '\n      ! Warning the mass conservation algorithm is not used !'
        production_text += '\n      call get_production_rates_exp(wdot,w,c,dtchem_sub)\n'
        production_text += '  end if\n'

    if exponential:
        production_text += '\n  if (.not. classic_chem) then'
        production_text += '\n      call get_production_rates_exp(wdot,w,c,dtchem_sub)\n'
        production_text += '  end if\n'
    if classical:
        production_text += '\n  if (classic_chem) then'
        production_text += '\n      call get_production_rates(wdot,w)\n'
        production_text += '  end if\n'

    text = text.format(precision, routine_name, PLog_text, QSS_text, TB_text, production_text)

    f.write(text)

def print_avbp_specific(print_variables, mech_variables, reactions_variables, semi_implicit):
    """Prints the AVBP specific calls in the f90 file

    Parameters
    ----------
    print_variables :
        dictionary containing the f90 file to write in and code specific infos
    mech_variables :
        dictionary of mechanism related parameters needed for computation
    reactions_variables :
        dictionary of reactions related parameters needed for computation
    semi_implicit :
        list of species to treat for semi-implicitation (set 'all' for all species)

    """

    def print_semi_implicit(print_variables, mech_variables, reactions_variables, species_list):
        """Write the computation of semi implicitation of stiff species

        Parameters
        ----------
        print_variables :
            dictionary containing the f90 file to write in and code specific infos
        mech_variables :
            dictionary of mechanism related parameters needed for computation
        reactions_variables :
            dictionary of reactions related parameters needed for computation
        species_list :
            list of species to treat for semi-implicitation (set 'all' for all species)

        Returns
        -------
        type
            None

        """
        f = print_variables['f']
        precision = print_variables['precision']

        non_qss_species = mech_variables['non_qss_species']
        non_qss_species_og = mech_variables['non_qss_species_og']
        mech = mech_variables['mech']
        timescales = mech_variables['timescales']
        nu = mech_variables['nu']
        inds = mech_variables['inds']
        indr = mech_variables['indr']

        reac_label = reactions_variables['reac_label']
        reac_direction = reactions_variables['reac_direction']
        is_reversible = reactions_variables['is_reversible']
        reverse_index = reactions_variables['reverse_index']

        if not timescales:
            logger.warning('WARNING: The semi-implicitation needs reviewing, as the timescales '
                           + 'of the species have not been computed they will be set to unity\n'
                           + 'The computation of the timescales is done with '
                           + 'tools.get_species_timescales(cases_list, mechanism)')
            for spec in non_qss_species:
                timescales[spec] = 1.0

        text = """\
! ----------------------------------------------- !
! Semi implicitation routine                      !
! ----------------------------------------------- !
subroutine semi_implicit(c, w, dtchem_sub)

"""

        # Get lists of species name with both Cantera and fortran naming convention
        if species_list == 'all':
            species_list_og = non_qss_species_og
            species_list = non_qss_species
        else:
            species_list_og = species_list.copy()
            species_list = tools.convert_to_valid_fortran_var(species_list)

        for spec in species_list:
            text += "  real({0}) :: creat_" + spec + ", destruct_" + spec + "\n"
        text += """\

  real({0}) :: denom, curdot
  real({0}), dimension(nspec) :: c
  real({0}), dimension(nreac+ nreac_reverse) :: w
  real({0}) :: dtchem_sub

"""
        text = text.format(precision)
        f.write(text)

        timescales = mech_variables['timescales']
        # Loop on species name according to Cantera (_og) or fortran naming convention
        for spec_og, spec in zip(species_list_og, species_list):
            index_glob = mech.species_index(spec_og)
            rindex = indr[inds == index_glob]
            text = "    ! Species " + spec + "\n    if (" + str(timescales[spec_og]) + "_{0} < dtchem_sub) then \n\n"
            text += "      creat_" + spec + " = 0.0_{0}"

            for myr in rindex:
                if nu[index_glob, myr] != 0:
                    flag = False
                    if nu[index_glob, myr] == 1:
                        text += '&' + '\n' + '         +'
                        flag = True
                    elif nu[index_glob, myr] > 1:
                        text += '&' + '\n' + '         + ' + str(nu[index_glob, myr]) + '_{0} *'
                        flag = True
                    if flag:
                        text += ' w(r' + str(reac_label[myr]) + reac_direction[myr] + ') '
                    if is_reversible[myr] == 1:
                        flag = False
                        if nu[index_glob, myr] != 0:
                            if nu[index_glob, myr] == -1:
                                text += '&' + '\n' + '         +'
                                flag = True
                            elif nu[index_glob, myr] < -1:
                                text += '&' + '\n' + '         + ' + str(-nu[index_glob, myr]) + '_{0} *'
                                flag = True
                            if flag:
                                text += ' w(r' + str(reac_label[myr]) + reac_direction[reverse_index[myr]] + ') '
            text += "\n\n"

            text += "      destruct_" + spec + " = 0.0_{0}"

            for myr in rindex:
                if nu[index_glob, myr] != 0:
                    flag = False
                    if nu[index_glob, myr] == -1:
                        text += '&' + '\n' + '         +'
                        flag = True
                    elif nu[index_glob, myr] < -1:
                        text += '&' + '\n' + '         + ' + str(nu[index_glob, myr]) + '_{0} *'
                        flag = True
                    if flag:
                        text += ' w(r' + str(reac_label[myr]) + reac_direction[myr] + ') '
                    if is_reversible[myr] == 1:
                        flag = False
                        if nu[index_glob, myr] != 0:
                            if nu[index_glob, myr] == 1:
                                text += '&' + '\n' + '         +'
                                flag = True
                            elif nu[index_glob, myr] > 1:
                                text += '&' + '\n' + '         + ' + str(-nu[index_glob, myr]) + '_{0} *'
                                flag = True
                            if flag:
                                text += ' w(r' + str(reac_label[myr]) + reac_direction[reverse_index[myr]] + ') '

            text += """\


      curdot = creat_{1} - destruct_{1}
      denom = 1.0_{0}  / ( 1.0_{0} + destruct_{1} / c(s{1}) * dtchem_sub )
      c(s{1}) = c(s{1}) + curdot * denom * dtchem_sub

    end if

"""
            text = text.format(precision, spec)
            f.write(text)

        text = """\

end subroutine semi_implicit

"""
        f.write(text)

    def internal_avbp(print_variables, semi_implicit):
        """Prints the routine called by AVBP containing the semi-implicitation of stiff species

        Parameters
        ----------
        print_variables :
            dictionary containing the f90 file to write in and code specific infos
        semi_implicit :
            list of species to treat for semi-implicitation (set 'all' for all species)

        """

        f = print_variables['f']
        precision = print_variables['precision']
        routine_name = print_variables['routine_name']
        Plog = print_variables['Plog']
        QSS = print_variables['QSS']
        TB = print_variables['TB']
        rrate = print_variables['rrate']
        exponential = print_variables['exponential']

        if rrate:
            var_add = ', rrate'
            use_add = """\n    use mod_input_param_defs, ONLY : nrrate_ARC, irrate_ARC
    use mod_solut, ONLY : Lrrate_ARC
    use mod_error, ONLY : print_error_and_quit"""
            declaration_add = """
    real(""" + str(precision) + """), dimension(nrrate_ARC) :: rrate
    integer :: i
    character(len=strl) :: message                                      !< error or debug message for screen output

"""
            calc_add = """\
    ! ARC reaction rate wanted
    if (irrate_ARC == 2) then
      if (nrrate_ARC > (nreac + nreac_reverse)) then
        write ( message, '(A,I0)' ) "Maximum number of reaction rate demanded exceeded, check if the number of reactions in the name of your f90 file is the same as in your  limit is :", (nreac + nreac_reverse)
        call print_error_and_quit ( err_message=message )
      end if
    else if (irrate_ARC == 1) then
      do i=1,nrrate_ARC
        if (Lrrate_ARC(i) > (nreac + nreac_reverse)) then
          write ( message, '(A,I0)' ) "Maximum number of reaction rate demanded exceeded, limit is :", (nreac + nreac_reverse)
          call print_error_and_quit ( err_message=message )
        end if
      end do
    end if

    rrate = 0.0
    do i=1,nrrate_ARC
      select case (irrate_ARC)
      case (2)
        rrate(i) = w(i)
      case (1)
        rrate(i) = w(Lrrate_ARC(i))
      case default
      end select
    end do

"""
        else:
            var_add = ''
            use_add = ''
            declaration_add = ''
            calc_add = ''

        text = """\
  ! ----------------------------------------------- !
  ! Internal AVBP routine                            !
  ! ----------------------------------------------- !
  subroutine internal_AVBP(P, T, thickness, c, wdot{5})

    use mod_param_defs
    use mod_misc_defs, ONLY: dtchem_sub{6}
    implicit none

    real({0}), dimension(nspec) :: c, wdot
    real({0}), dimension(nqss) :: cqss
    real({0}), dimension(nreac + nreac_reverse) :: w,k
    real({0}), dimension(nTB + nFO) :: M

    real({0}) :: T,P,thickness
{7}
{10}
    call get_rate_coefficients(k,M,T,P){3}{4}
    call get_reaction_rates(w,k,M,c,cqss)
{1}
    ! Evaluate production rates
{9}
{8}
    return
  end subroutine internal_AVBP

end module mod_{2}

"""
        if semi_implicit:
            semi_implicit_text = """\

    ! Necessary semi-implicitation for stiff species
    if (semiImplicit .eqv. .true.) then
      call semi_implicit(c, w, dtchem_sub)
      ! Reevaluate reaction rates with implicit stiff species concentrations{4}
      call get_reaction_rates(w,k,M,c,cqss)
    end if
"""
        else:
            semi_implicit_text = ''

        if Plog:
            PLog_text = '\n    call get_pdep_rate_coefficients(k,T,P)\n'
        else:
            PLog_text = ''

        if QSS:
            QSS_text = '\n    call get_qss(cqss,c,k,M)\n'
        else:
            QSS_text = ''

        if TB:
            TB_text = '\n  call get_thirdbodies(M,c)\n'
        else:
            TB_text = ''

        if exponential:
            exp_text = '    call get_production_rates_exp(wdot,w,c,dtchem_sub,thickness)'
        else:
            exp_text = '    call get_production_rates(wdot,w)'

        text = text.format(precision, semi_implicit_text, routine_name,
                           PLog_text, QSS_text, var_add, use_add, declaration_add, calc_add, exp_text, TB_text)

        f.write(text)

    def avbp_interface(print_variables):
        """Prints the routine called by AVBP during the run

        Parameters
        ----------
        print_variables :
            dictionary containing the f90 file to write in and code specific infos

        """
        f = print_variables['f']
        precision = print_variables['precision']
        routine_name = print_variables['routine_name']
        rrate = print_variables['rrate']

        text = """\
! ---------------------------------------- !
! Actual routine called from AVBP          !
! ---------------------------------------- !

subroutine {1}(nnode,neqs,rhoinv,press,tempe,w_spec,wmol,source_spec{2})

  use mod_param_defs
  use mod_{1}, ONLY: internal_AVBP{3}
  use mod_compute_defs, ONLY: thick
  implicit none

  ! In/out variables
  integer, intent(IN) :: nnode, neqs
  real({0}), dimension(1:neqs), intent(IN) :: wmol
  real({0}), dimension(1:nnode), intent(IN) :: rhoinv,press,tempe
  real({0}), dimension(1:neqs,1:nnode), intent(IN) :: w_spec
  real({0}), dimension(1:neqs,1:nnode), intent(OUT) ::source_spec{4}

  ! Local variables
  real({0}), dimension(1:neqs) :: C
  real({0}), dimension(1:neqs) :: source_spec_buf{5}
  real({0}) :: P,T, thickness
  integer :: n,k

  do n=1,nnode
     P = press(n)
     T = tempe(n)
     thickness = thick(n)

     ! Activity concentrations in mol/m3
     C(:) = min( w_spec(:, n), one/rhoinv(n) ) ! bugfix
     C = C / wmol
     C = max(C, 0.0_pr)

     !   The internal ARCANE routine is called
     call internal_AVBP ( P, T, thickness, C, source_spec_buf{6} )

     !   Conversion from mol/m3/s to kg/m3/s
     source_spec(:,n) = source_spec_buf(:) * wmol(:)
     {8}

  end do

end subroutine {1}
{7}
"""

        if rrate:
            var_add = ', rrate_ARC'
            use_add = '\n  use mod_input_param_defs, ONLY : nrrate_ARC'
            declaration_add = '\n  real(' + str(
                    precision) + '), dimension(1:nrrate_ARC,1:nnode), intent(OUT) :: rrate_ARC\n'
            declaration_add_2 = '\n  real(' + str(precision) + '), dimension(1:nrrate_ARC) :: rrate_buf\n'
            var_add_2 = ', rrate_buf'
            calc_add = """
subroutine get_reacname_""" + str(routine_name) + """(reacexp_ARC)
  use mod_input_param_defs, ONLY : nrrate_ARC, irrate_ARC
  use mod_solut, ONLY : Lrrate_ARC
  use mod_""" + str(routine_name) + """, ONLY : reacexp, reaction_expressions
  implicit none

  character(len=65), dimension(nrrate_ARC) :: reacexp_ARC
  integer :: i

  call reaction_expressions
  do i=1,nrrate_ARC
    if (irrate_ARC==1) then
      reacexp_ARC(i) = reacexp(Lrrate_ARC(i))
    else
      reacexp_ARC(i) = reacexp(i)
    end if
  end do

end subroutine get_reacname_""" + str(routine_name)
            get_add = """
     !   Get the reaction rate
     rrate_ARC(:,n) = rrate_buf(:)"""

        else:
            var_add = ''
            use_add = ''
            declaration_add = ''
            declaration_add_2 = ''
            var_add_2 = ''
            calc_add = ''
            get_add = ''

        text = text.format(precision, routine_name,
                           var_add, use_add, declaration_add, declaration_add_2, var_add_2, calc_add, get_add)

        f.write(text)

    if semi_implicit:
        print_semi_implicit(print_variables, mech_variables, reactions_variables, semi_implicit)

    internal_avbp(print_variables, semi_implicit)
    avbp_interface(print_variables)

def print_yales2_specific(print_variables):
    """Prints the YALES2 specific calls in the f90 file

    Parameters
    ----------
    print_variables :
        dictionary containing the f90 file to write in and code specific infos

    """

    def internal_yales2(print_variables):
        """Prints the routine called by AVBP containing the semi-implicitation of stiff species

        Parameters
        ----------
        print_variables :
            dictionary containing the f90 file to write in and code specific infos

        """

        f = print_variables['f']
        precision = print_variables['precision']
        routine_name = print_variables['routine_name']
        Plog = print_variables['Plog']
        QSS = print_variables['QSS']
        TB = print_variables['TB']

        text = """\
    ! ----------------------------------------------- !
    ! internal YALES2 routine                         !
    ! ----------------------------------------------- !
    subroutine internal_yales2(P, T, y, wdot)

      implicit none

      real({0}), dimension(nspec) :: y, c, wdot, cdot
      real({0}), dimension(nqss) :: cqss
      real({0}), dimension(nreac + nreac_reverse) :: w,k
      real({0}), dimension(nTB + nFO) :: M

      real({0}) :: P, T, rho

      ! Convert to concentrations
      call y2c(y, W_sp, P, T, c)

      ! Evaluate QSS concentrations and reaction rates{4}
      call get_rate_coefficients(k, M, T, P){2}{3}
      call get_reaction_rates(w, k, M, c, cqss)

      ! Evaluate production rates
      call get_production_rates(wdot,w)

      return
    end subroutine internal_yales2

end module mod_{1}

"""
        if Plog:
            PLog_text = '\n      call get_pdep_rate_coefficients(k,T,P)\n'
        else:
            PLog_text = ''

        if QSS:
            QSS_text = '\n      call get_qss(cqss, c, k, M)\n'
        else:
            QSS_text = ''

        if TB:
            TB_text = '\n      call get_thirdbodies(M,c)\n'
        else:
            TB_text = ''

        text = text.format(precision, routine_name, PLog_text, QSS_text, TB_text)

        f.write(text)

    def yales2_interface(print_variables):
        """Prints the routine called by AVBP during the run

        Parameters
        ----------
        print_variables :
            dictionary containing the f90 file to write in and code specific infos

        """
        f = print_variables['f']
        precision = print_variables['precision']
        routine_name = print_variables['routine_name']

        text = """\
! ---------------------------------------- !
! Actual routine called from YALES2        !
! ---------------------------------------- !

subroutine {1}(nnode,neqs,rhoinv,press,tempe,w_spec,wmol,source_spec)

  use mod_{1}, ONLY: internal_yales2
  implicit none

  integer, parameter :: {0} = selected_real_kind(15,307)

  ! In/out variables
  integer, intent(IN) :: nnode, neqs
  real({0}), dimension(1:neqs), intent(IN) :: wmol
  real({0}), dimension(1:nnode), intent(IN) :: rhoinv,press,tempe
  real({0}), dimension(1:neqs,1:nnode), intent(IN) :: w_spec
  real({0}), dimension(1:neqs,1:nnode), intent(OUT) ::source_spec

  ! Local variables
  real({0}), dimension(1:neqs) :: Y, source_spec_buf
  real({0}) :: P,T
  integer :: n,k

  do n=1,nnode
     P = press(n)
     T = tempe(n)
     Y(1:neqs) = w_spec(1:neqs,n)

     !   The internal ARCANE routine is called
     call internal_yales2 ( P, T, Y, source_spec_buf)

     !   Conversion from mol/m3/s to kg/m3/s
     do k=1,neqs
        source_spec(k,n) = source_spec_buf(k) * wmol(k)
     end do

  end do

end subroutine {1}
"""

        text = text.format(precision, routine_name)

        f.write(text)

    internal_yales2(print_variables)
    yales2_interface(print_variables)

def convert2fvar(name):
    names = [name]
    names = tools.convert_to_valid_fortran_var(names)
    return names[0]

def print_reaction_rate_rhs_Jac(print_variables,constants, mech_variables,reactions_variables):
    """Prints the routine to fill the Rhs and Jacobian matrix for the reaction ODEs

    Parameters
    ----------
    print_variables :
        dictionary containing the f90 file to write in and code specific infos

    """

    f = print_variables['f']
    precision = print_variables['precision']

    reac_label = reactions_variables['reac_label']

    species = mech_variables['species']
    mech = mech_variables['mech']
    reactions = mech.reaction

    text = """\
  ! ----------------------------------------------- !
  ! Fill the Rhs martrix for ODE solver             !
  ! ----------------------------------------------- !
  subroutine fill_rhs_matrix(rhs, w)
    implicit none
    real({0}), dimension(nreac + nreac_reverse) :: w     ! kinetics frequency and reaction rate

    real({0}), dimension(nspec) :: rhs

""".format(precision)

    # From the reactions, get the RHS of each species
    for i, species_name in enumerate(species):
        line_head = '    rhs(s' + species_name + ') = '
        line = "0.0_" + precision
        for j, reaction in enumerate(reactions):
            reactants = reaction.reactants
            products = reaction.products
            if species_name in reactants:
                stoich = reactants[species_name]
                if stoich != 1:
                    token = '+' + str(stoich) + '_'+precision+'*w(r' + str(reac_label[j]) + '_f)'
                else:
                    token = '+w(r' + str(reac_label[j]) + '_f)'
                if (len(line.split("\n")[-1])>80):
                    line += '&\n            &'
                line += token
            if species_name in products:
                stoich = products[species_name]
                if stoich != 1:
                    token = '-' + str(stoich) + '_'+precision+'*w(r' + str(reac_label[j]) + '_f)'
                else:
                    token = '-w(r' + str(reac_label[j]) + '_f)'
                if (len(line.split("\n")[-1])>80):
                    line += '&\n            &'
                line += token

        text += (line_head + line + '\n')



    text += """\
    
    return
  end subroutine fill_rhs_matrix

   
"""

    # for Jac
    text += """\
  ! ----------------------------------------------- !
  ! Fill the Jacobian matrix for ODE solver         !
  ! ----------------------------------------------- !
  subroutine fill_jac_matrix(jac, c, k)
    implicit none
    real({0}), dimension(nspec) :: c                        ! concentrations
    real({0}), dimension(nreac + nreac_reverse) :: k     ! kinetics frequency

    real({0}), dimension(nspec,nspec) :: jac
""".format(precision)
    
    for i, species_i in enumerate(species):
        for j, species_j in enumerate(species):
            #rhs is the change rate of species_i 
            #now we need to get its derivative with respect to species_j
            #its position is in Jac(i,j)

            # for change rate of i, first look over all reactions
            # for each reaction, do derivative of rhs_i with respect to species_j
            # at last, linear combination of all reactions
            line_head = '        jac(s' + species_i + ',s' + species_j + ') = '
            line = "0.0_" + precision
            for k, reaction in enumerate(reactions):
                reactants = reaction.reactants
                products = reaction.products
                order = reaction.orders

                # if species_i is not in reactants or products, then the rhs is 0 and its derivative to j is 0
                if species_i not in reactants.keys() and species_i not in products.keys():
                    continue

                # if species_i is in reactants or products, and species_j is in reaction rate calculation
                # if j is not in reaction rate calculation, then the derivative is 0
                # else do derivative to j
                else:
                    # know how to calculate the reaction rate
                    rate = {}
                    if len(order) > 0:
                        rate = order
                    else:
                        rate = reactants
                    if species_j not in rate.keys():
                        continue
                    else:
                        # Get the constant term based on species_i
                        if species_i in reactants.keys():
                            token = ' -'+str(float(reactants[species_i])) + '_'+precision
                        else:
                            token = ' +'+str(float(products[species_i])) + '_'+precision
                        token += '*k(r' + str(reac_label[k]) + '_f)'
                        for spec in rate.keys():
                            if spec != species_j:
                                token += '*c(s' + spec + ')**' + str(float(rate[spec]))+'_'+precision
                            else:
                                stoich = rate[spec]
                                if float(stoich) != 1.0:
                                    token += '*'+str(float(rate[spec]))+'_'+precision+'*c(s' + spec + ')**' + str(float(stoich-1))+'_'+precision

                        if (len(line.split("\n")[-1])>80):
                            line += '&\n            &'
                        line += token
            text += (line_head + line + '\n')


    text += """\

    return
  end subroutine fill_jac_matrix


"""
    
    f.write(text)